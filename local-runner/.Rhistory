scdata <- RunUMAP(scdata, reduction='pca', dims = 1:numPCs, verbose = F, umap.method = "uwot", min.dist = umap_min_distance, metric = umap_distance_metric, return.model = FALSE)
?RunUMAP
method <- 'seuratv4'
scdata <- blah
# had to add this to avoid: "Error: Cannot add a different number of cells than already present)"
# can someone verify that this is appropriate
Seurat::DefaultAssay(scdata) <- "RNA"
# Else, we are in unisample experiment and we only need to normalize
scdata <- Seurat::NormalizeData(scdata, normalization.method = normalisation, verbose = FALSE)
scdata <-Seurat::FindVariableFeatures(scdata, selection.method = "vst", nfeatures = nfeatures, verbose = FALSE)
# Scale in order to compute PCA
scdata <- Seurat::ScaleData(scdata, verbose = FALSE)
# HARDCODE numPCs to 50
scdata <- Seurat::RunPCA(scdata, npcs = 50, features = Seurat::VariableFeatures(object=scdata), verbose = FALSE)
# Compute embedding with default setting to get an overview of the performance of the batch correction
scdata <- Seurat::RunUMAP(scdata, reduction='pca', dims = 1:numPCs, verbose = FALSE, umap.method = "uwot", min.dist = umap_min_distance, metric = umap_distance_metric, return.model = FALSE)
# Compute explained variance for the plot2
eigValues = (scdata.integrated@reductions$pca@stdev)^2  ## EigenValues
scdata.integrated <- scdata
# Compute explained variance for the plot2
eigValues = (scdata.integrated@reductions$pca@stdev)^2  ## EigenValues
varExplained = eigValues / sum(eigValues)
# the result object will have to conform to this format: {data, config, plotData : {plot1, plot2}}
result <- list(
data = scdata.integrated,
config = config,
plotData = list(
# Plot1 --> embedding plot by UMAP
plot1 = list(x=scdata.integrated@reductions$umap@cell.embeddings[, 1], y=scdata.integrated@reductions$umap@cell.embeddings[, 1]),
plot2 = list(proportion_variance_explained = varExplained, nPCs = 1:50)
)
)
config <- NULL
# the result object will have to conform to this format: {data, config, plotData : {plot1, plot2}}
result <- list(
data = scdata.integrated,
config = config,
plotData = list(
# Plot1 --> embedding plot by UMAP
plot1 = list(x=scdata.integrated@reductions$umap@cell.embeddings[, 1], y=scdata.integrated@reductions$umap@cell.embeddings[, 1]),
plot2 = list(proportion_variance_explained = varExplained, nPCs = 1:50)
)
)
result
cat('Dimensions of scdata:', dim(scdata), '\n')
?Seurat::NormalizeData
varExplained
plot2 <- lapply(seq_along(varExplained), function(i) c(PC=i, percentVariance=varExplained[i]))
head(plot2)
scseq$cluster
scdata$seurat_clusters
blah <- readRDS("~/Documents/Batcave/biomage/worker/data/e52b39624588791a7889e39c617f669e/r.rds")
max(blah$nCount_RNA)
counts <- blah@assays$RNA@data
numi <- Matrix::colSums(counts)
max(numi)
hist(blah$nCount_RNA)
hist(blah$nCount_RNA, 20)
library(vikram)
dat <- readxl::read_excel('data/raw/Vikram Master Log Aug2020.xlsx', sheet = 'MAS')
colnames(dat)
dat$`Oral Steroids`
dat$`Pulse Steroids`
dat$Date
dat <- dat[dat$Date > "2015-05-18 UTC" & dat$Date < "2017-02-01 UTC", ]
par(mfrow=c(1,1))
for (clin in clins) plot_clin(clin, dat)
library(vikram)
for (clin in clins) plot_clin(clin, dat)
clins <- c('Steroids', 'Pulse Steroids')
for (clin in clins) plot_clin(clin, dat)
clins <- c('Oral Steroids', 'Pulse Steroids')
for (clin in clins) plot_clin(clin, dat)
df <- dat[, c(clin, 'Date')]
df <- df[!is.na(df[[1]]) & df$Date> as.POSIXct('01-01-19', tz='UTC', '%m-%d-%y'),]
y <- df[[1]]
plot(df$Date, y, xaxt="n", type = 'o', ylab = colnames(df)[1], xlab = 'DATE')
dat$Stery
y
head(y)
head(df)
clin
df <- dat[, c(clin, 'Date')]
head(df)
df$`Oral Steroids`[is.na(df$`Oral Steroids`)] <- 0
y <- df[[1]]
plot(df$Date, y, xaxt="n", type = 'o', ylab = colnames(df)[1], xlab = 'DATE')
axis.POSIXct(1, at=seq(min(df$Date), max(df$Date), by="months"), format="%m-%Y")
clin <- 'Pulse Steroids'
dat <- dat[dat$Date > "2015-05-18 UTC" & dat$Date < "2017-02-01 UTC", ]
df <- dat[, c(clin, 'Date')]
df$`Oral Steroids`[is.na(df$`Oral Steroids`)] <- 0
y <- df[[1]]
df$`Oral Steroids`[is.na(df$`Pulse Steroids`)] <- 0
df <- dat[, c(clin, 'Date')]
df$`Pulse Steroids`[is.na(df$`Pulse Steroids`)] <- 0
y <- df[[1]]
plot(df$Date, y, xaxt="n", type = 'o', ylab = colnames(df)[1], xlab = 'DATE')
axis.POSIXct(1, at=seq(min(df$Date), max(df$Date), by="months"), format="%m-%Y")
library(Seurat)
library(magrittr)
library(parallel)
library(Matrix)
require(data.table)
library(RJSONIO)
library(ggplot2)
library(MASS)
install.packages('RJSONIO')
install.packages('Seurat')
blah <- readRDS('/home/alex/Documents/Batcave/biomage/data-ingest/output/rds_samples/brain.rds')
dim(blah)
table(blah$samples)
library(crossmeta)
library(Biobase)
library(limma)
library(drugseqr)
data_dir <- 'data/raw'
gse_name <- 'GSE3701'
# two color
gse_dir <- file.path(data_dir, gse_name)
files <- list.files(gse_dir, '^GSM')
RG <- limma::read.maimages(files = files,
source = 'genepix',
path = gse_dir)
# setup design matrix
eset <- readRDS('data/raw/vikram_whole_blood_2019_eset.rds')
eset <- eset[, c(3, 1, 2, 4, 5, 6, 7, 8)]
dates <- gsub('^.+?-200396-(.+?)$', '\\1', colnames(eset))
y <- exprs(eset)
lib.size <- eset$lib.size * eset$norm.factors
# post vs pre GH
group <- factor(rep(c('pre', 'post'), each = 4), levels = c('pre', 'post'))
design <- stats::model.matrix(~0 + group)
contrast <- limma::makeContrasts('grouppost-grouppre', levels = design)
keep <- edgeR::filterByExpr(y, design)
v <- voom(y[keep,], design, lib.size = lib.size, plot=TRUE)
in.v <- common %in% row.names(v)
crossmeta::get_raw(gse_name, data_dir)
# two color
gse_dir <- file.path(data_dir, gse_name)
files <- list.files(gse_dir, '^GSM')
RG <- limma::read.maimages(files = files,
source = 'genepix',
path = gse_dir)
eset <- crossmeta:::getGEO(gse_name)[[1]]
all.equal(colnames(eset), colnames(MA))
all.equal(colnames(eset), colnames(RG))
pdata <- pData(eset)
pdata$group <- gsub('^[^ ]+ (.+?)_rep \\d$', '\\1', pdata$title)
pdata$group[14] <- 'THP-1_0Âµg hgh/mL_0min'
RGb <- limma::backgroundCorrect(RG, method="normexp", offset=50)
MA <- limma::normalizeWithinArrays(RGb)
MA$genes$GENE_SYMBOL <- fData(eset)$GENE_SYMBOL
MA <- MA[MA$genes$GENE_SYMBOL != '', ]
# PBMCs
is.pbmc <- grepl('PBMC', pdata$title)
pdata_pbmc <- pdata[is.pbmc, ]
MA_pbmc <- MA[, is.pbmc]
# channel 1 is hgh treated
MA_pbmc$targets$Cy3 <- ifelse(pdata_pbmc$label_ch1 == 'Cy3', 'hgh', 'ctrl')
MA_pbmc$targets$Cy5 <- ifelse(pdata_pbmc$label_ch1 == 'Cy5', 'hgh', 'ctrl')
# dye swap
design <- cbind(DyeEffect=1, HGHvsCTRL=ifelse(MA_pbmc$targets$Cy3 == 'hgh', 1, -1))
fit <- lmFit(MA_pbmc, design)
fit <- eBayes(fit)
tt_dye <- topTable(fit, coef = 'DyeEffect')
tt_hgh <- topTable(fit, coef = 'HGHvsCTRL', n = Inf)
View(tt_hgh)
# top 200 in GH PBMCS --
sig.hgh <- toupper(tt_hgh$GENE_SYMBOL[1:200])
# GO genes that are IFNG --
gs.names <- drugseqr:::get_gs.names()
gslist <- drugseqr:::get_gslist()
# GO genes that are IFNG --
gs.names <- drugseqr.data:::get_gs.names()
# GO genes that are IFNG --
gs.names <- drugseqr:::get_gs.names()
# GO genes that are IFNG --
gs.names <- drugseqr:::get_gs.names()
# GO genes that are IFNG --
gslist <- drugseqr:::get_gslist()
# GO genes that are IFNG --
gslist <- drugseqr:::get_gslist()
type = 'go'
gs_dir = '/srv/drugseqr/gs_dir'
species = 'Hs'
PathwayID <- GeneID <- SYMBOL <- NULL
if (!dir.exists(gs_dir)) dir.create(gs_dir)
fname <- paste('gslist', type, species, 'rds', sep = '.')
gslist_path <- file.path(gs_dir, fname)
file.exists(gslist_path)
orgPkg <- paste0("org.",species,".eg.db")
require(orgPkg, character.only = TRUE, quietly = TRUE)
#	Get access to package of GO terms
suppressPackageStartupMessages(OK <- requireNamespace("GO.db",quietly=TRUE))
if(!OK) stop("GO.db package required but is not installed (or can't be loaded)")
#	Get access to required annotation functions
suppressPackageStartupMessages(OK <- requireNamespace("AnnotationDbi",quietly=TRUE))
if(!OK) stop("AnnotationDbi package required but is not installed (or can't be loaded)")
#	Load appropriate organism package
suppressPackageStartupMessages(OK <- requireNamespace(orgPkg,quietly=TRUE))
if(!OK) stop(orgPkg," package required but is not installed (or can't be loaded)")
#	Get GO to Entrez Gene mappings
obj <- paste0("org.",species,".egGO2ALLEGS")
egGO2ALLEGS <- tryCatch(utils::getFromNamespace(obj,orgPkg), error=function(e) FALSE)
if(is.logical(egGO2ALLEGS)) stop("Can't find gene ontology mappings in package ",orgPkg)
# Entrez gene to symbol
# TODO for Hs: get from toupper(hs[EG.GO$gene_id, SYMBOL_9606]) so that consistent with original annotation
EG.GO <- AnnotationDbi::toTable(egGO2ALLEGS)
EG.GO$SYMBOL <- AnnotationDbi::mapIds(get(orgPkg), EG.GO$gene_id, column = 'SYMBOL', keytype = 'ENTREZID')
gslist <- split(EG.GO, EG.GO$go_id)
gslist <- lapply(gslist, function(df) {tmp <- df$gene_id; names(tmp) <- df$SYMBOL; tmp})
saveRDS(gslist, gslist_path)
# GO genes that are IFNG --
dir <- tempdir()
gslist <- drugseqr:::get_gslist(gs_dir = dir)
gs.names <- drugseqr:::get_gs.names(gslist, gs_dir = dir)
gh.go <- names(grep('growth hormone', gs.names, value = T))
gh.genes <- unique(unlist(lapply(gslist[gh.go], names), use.names = FALSE))
length(gh.genes)
# also significant in public data
common <- intersect(gh.genes, sig.hgh)
logfcs <- tt_hgh[common, 'logFC']
# only one so just use all
common <- gh.genes
common
# setup design matrix
eset <- readRDS('data/raw/vikram_whole_blood_2019_eset.rds')
eset <- eset[, c(3, 1, 2, 4, 5, 6, 7, 8)]
dates <- gsub('^.+?-200396-(.+?)$', '\\1', colnames(eset))
y <- exprs(eset)
lib.size <- eset$lib.size * eset$norm.factors
# post vs pre GH
group <- factor(rep(c('pre', 'post'), each = 4), levels = c('pre', 'post'))
design <- stats::model.matrix(~0 + group)
contrast <- limma::makeContrasts('grouppost-grouppre', levels = design)
keep <- edgeR::filterByExpr(y, design)
v <- voom(y[keep,], design, lib.size = lib.size, plot=TRUE)
in.v <- common %in% row.names(v)
limma::roast(v, index = common[in.v], design = design, contrast = contrast)
viktt <- read.csv('data/raw/bulk_vikram_whole_blood_2019_POST_vs_PRE_0SV_2020-09-14/top_table.csv', row.names = 1)
View(viktt[row.names(viktt) %in% common, ])
v
v$E
head(v$E)
blah <- v$E[c('GHR', 'IGF1'), ]
head(blah)
# GHR and IGF-1
blah <- v$E[c('GHR', 'IGF1'), ]
df <- data.frame(GHR = blah['GHR', ], GH = group)
plot(GHR ~ GH, data=df)
stripchart(GHR ~ GH, data=df)
plot(GHR ~ GH, data=df)
plot(x=df$GH, y=df$GHR)
stripchart(GHR~GH, data=df, method="stack",at=0)
stripchart(GHR~GH, data=df, method="stack")
stripchart(GHR~GH, data=df, method="stack", at=c(0,1))
stripchart(GHR~GH, data=df, method="stack")
dots(GHR~GH, data=df, method="stack")
library(ggplot2)
ggplot(df, aes(GH, GHR)) + geom_point()
df <- data.frame(GHR = blah['IGF1', ], GH = group)
ggplot(df, aes(GH, GHR)) + geom_point()
# GHR and IGF-1
blah <- v$E[c('GHR', 'IGF1', 'GH'), ]
limma::roast(v, index = common[in.v], design = design, contrast = contrast)
res <- data.table::fread('data/raw/PASS.HIGH_IMPACT.AC_LT_50.txt')
View(res)
res <- data.table::fread('data/raw/PASS.IMPACT.txt')
View(res)
res <- data.table::fread('data/raw/PASS.IMPACT.txt')
View(res)
dim(res)
res <- data.table::fread('data/raw/PASS.HIGH_IMPACT.AC_LT_50.txt')
res <- data.table::fread('data/raw/PASS.IMPACT.txt')
View(res)
blah <- readRDS('/home/alex/Documents/Batcave/biomage/inframock/src/data/r.rds')
dim(blah)
blah$orig.ident[1:5]
blah <- readRDS('/home/alex/Documents/Batcave/biomage/inframock/src/data/r.rds.gz')
blah$orig.ident[1:5]
vickyfiltered <- readRDS('/home/alex/Downloads/r_blah.rds')
data<-vickyfiltered
#Get the annotation matrix with the geneid to name translation, and the subset with the correct names.
df <- data@misc$gene_annotations
genesSubset <- subset(df, toupper(df$name) %in% toupper(req$body$genes))
#
#Get the expression values for those genes in the corresponding matrix.
geneExpression <-data@assays$RNA@data[genesSubset$input,,drop=FALSE]
geneExpression <- as.data.frame(t(as.matrix(geneExpression)))
geneExpression$cells_id <- data@meta.data$cells_id
req <- list(body = list(genes = c('Gzma', 'Lyz2', 'Igkc', 'Cd74')))
#Get the annotation matrix with the geneid to name translation, and the subset with the correct names.
df <- data@misc$gene_annotations
genesSubset <- subset(df, toupper(df$name) %in% toupper(req$body$genes))
#
#Get the expression values for those genes in the corresponding matrix.
geneExpression <-data@assays$RNA@data[genesSubset$input,,drop=FALSE]
geneExpression <- as.data.frame(t(as.matrix(geneExpression)))
geneExpression$cells_id <- data@meta.data$cells_id
geneExpression <- geneExpression[ order(geneExpression$cells_id), ]
geneExpression <- geneExpression %>%
complete(cells_id = seq(0,max(data@meta.data$cells_id))) %>%
select(-cells_id)
library(dplyr)
library(tidyr)
geneExpression <- geneExpression %>%
complete(cells_id = seq(0,max(data@meta.data$cells_id))) %>%
select(-cells_id)
# worried about duplicate gene row.names in @data
symbol_idx <- match(colnames(geneExpression), genesSubset$input)
colnames(geneExpression) <- genesSubset$name[symbol_idx]
head(geneExpression)
class(geneExpression)
head(geneExpression)
sd(1:5)
print('unisample detected')
blah <- function() {
browser()
a <- 4
a <- zozoz
}
blah()
a <- zozoz
blah <- readRDS('/home/alex/Documents/Batcave/biomage/inframock/data/e52b39624588791a7889e39c617f669e/r.rds')
dim(blah)
blah@assays$RNA@data[1:5,1:5]
list(blah = 1, dog = 3)
blah <- list(blah = 1, dog = 3)
length(blah)
blah <- list(blah = 1, dog = 3, config = list(blah = 3))
print(blah)
str(blah)
blah <- list(blah = 1, dog = 3, config = list(blah = 'logNormalize'))
str(blah)
?IntegrateData
blah <- readRDS('/home/alex/Documents/Batcave/biomage/inframock/data/e52b39624588791a7889e39c617f669e/r.rds')
blah@assays$RNA@data[1:5,1:5]
blah@assays$RNA@counts
blah@assays$RNA@counts[1:5,1:5]
dim(blah@assays$RNA@counts)
blah@assays$RNA@counts[1:5,1:5]
blah@assays$RNA@data[1:5,1:5]
blah@assays$integrated[1:5,1:5]
dim(blah@assays$integrated)
dim(blah)
dim(blah@assays$RNA@counts)
blah <- ls()
scdata <- 1
config <- list()
task_name <- 'dataIntegration'
sample_id <- '123019283'
blah <- ls()
blah
all_values_def <- list(
scdata = scdata,
config = config,
task_name = task_name,
sample_id = sample_id
)
saveRDS(all_values_def, 'blah.rds')
load_last_debug(task_name) {
blah <- readRDS('blah.rds')
}
load_last_debug <- function(task_name) {
blah <- readRDS('blah.rds')
}
isTRUE('true')
isTRUE('TRUE')
as.logical('true')
as.logical('false')
as.logical('1')
as.logical('2')
as.logical('0')
as.logical(1)
as.logical(0)
?save.image()
ls(all.names = TRUE)
?save
taskName <- 'dataIntegration'
message('DEBUG FOR: ', taskName)
message('DEBUG TRUE FOR: ', taskName)
message('RUN `load("', debug_path, '")` ', 'to restore environment.')
debug_path <- file.path('/local-runner/debug', paste0(taskName, '.RData'))
message('RUN `load("', debug_path, '")` ', 'to restore environment.')
message("RUN `load('", debug_path, "'")` ', 'to restore environment.')
}
}
task <- function(scdata, config,task_name,sample_id){
.args <- as.list(match.call()[-1])
handle_debug(.args)
# increase maxSize from the default of 500MB to 32GB
# TODO: ask Marcell for his opinion
options(future.globals.maxSize= 32 * 1024 * 1024^2)
# Check wheter the filter is set to true or false
# So far we only support Seurat V3
scdata.integrated <- run_dataIntegration(scdata, config)
# Compute explained variance for the plot2
eigValues = (scdata.integrated@reductions$pca@stdev)^2  ## EigenValues
varExplained = eigValues / sum(eigValues)
# As a short solution, we are going to store an intermediate slot for the numPCs, since this parameter is required when performing
# the computeEmdedding. The main reason to do not have in the config.configureEmbedding is that this parameter does not change in the configureEmbedding step.
scdata.integrated@misc[["numPCs"]] <- config$dimensionalityReduction$numPCs
scdata.integrated <- colorObject(scdata.integrated)
cells_order <- rownames(scdata.integrated@meta.data)
plot1_data <- unname(purrr::map2(scdata.integrated@reductions$umap@cell.embeddings[, 1],scdata.integrated@reductions$umap@cell.embeddings[, 2],function(x,y){c("x"=x,"y"=y)}))
#Adding color and sample id
plot1_data <- purrr::map2(plot1_data,
unname(scdata.integrated@meta.data[cells_order, "samples"]),
function(x,y){append(x,list("sample"=y))}
)
plot1_data <- purrr::map2(plot1_data,
unname(scdata.integrated@meta.data[cells_order, "color_samples"]),
function(x,y){append(x,list("col"=y))}
)
plot2_data <- unname(purrr::map2(1:50,varExplained,function(x,y){c("PC"=x,"percentVariance"=y)}))
plots <- list()
plots[generate_plotuuid("", task_name, 0)] <- list(plot1_data)
plots[generate_plotuuid("", task_name, 1)] <- list(plot2_data)
# For now config is not updated, since there is not new changes
# config <- ...
# the result object will have to conform to this format: {data, config, plotData : {plot1, plot2}}
result <- list(
data = scdata.integrated,
config = config,
plotData = plots
)
return(result)
}
# This function covers
#   - Integrate the data using the variable "type" (in case of data integration method is selected) and normalize using LogNormalize method.
#   - Compute PCA analysis
#   - To visualize the results of the batch effect, an UMAP with default setting has been made.
# Seurat V3 pipeline (see for other methods: https://satijalab.org/seurat/archive/v3.0/integration.html)
run_dataIntegration <- function(scdata, config){
method <- config$dataIntegration$method
nfeatures <- config$dataIntegration$methodSettings[[method]]$numGenes
normalization <- config$dataIntegration$methodSettings[[method]]$normalisation
#Caps lock independent just in case anything goes wrong in dynamo or wherever.
if (toupper(normalization)=="LOGNORMALIZE"  | toupper(normalization)=="LOGNORMALISE") normalization<-"LogNormalize"
# Q: Should be the numPCs input for the RunPCA? Since we are looking into the explained variance I suggest to RunPCA with 50 and only
# use this parameter for the data integration purpose.
numPCs <- config$dimensionalityReduction$numPCs
#HARDCODE
# We require just to get an overview of the data-integration
umap_min_distance <- 0.3
umap_distance_metric <- "euclidean"
# temporary to make sure we don't run integration if unisample
message("RUN `load('", debug_path, "')` ", 'to restore environment.')
message('DEBUG TRUE FOR: ', taskName)
message("RUN `load('", debug_path, "')` ", 'to restore environment.')
message("RUN load('", debug_path, "') ", 'to restore environment.')
# increase maxSize from the default of 500MB to 32GB
# TODO: ask Marcell for his opinion
options(future.globals.maxSize= 32 * 1024 * 1024^2)
# Check wheter the filter is set to true or false
# So far we only support Seurat V3
scdata.integrated <- run_dataIntegration(scdata, config)
# Compute explained variance for the plot2
eigValues = (scdata.integrated@reductions$pca@stdev)^2  ## EigenValues
varExplained = eigValues / sum(eigValues)
# As a short solution, we are going to store an intermediate slot for the numPCs, since this parameter is required when performing
# the computeEmdedding. The main reason to do not have in the config.configureEmbedding is that this parameter does not change in the configureEmbedding step.
scdata.integrated@misc[["numPCs"]] <- config$dimensionalityReduction$numPCs
scdata.integrated <- colorObject(scdata.integrated)
cells_order <- rownames(scdata.integrated@meta.data)
plot1_data <- unname(purrr::map2(scdata.integrated@reductions$umap@cell.embeddings[, 1],scdata.integrated@reductions$umap@cell.embeddings[, 2],function(x,y){c("x"=x,"y"=y)}))
blah <- function() {
browser()
a <- 4
print(a)
}
blah()
a <- 4
a
a <- sdfjkhsdfhj
load_debug('dataIntegration')
load("~/Documents/Batcave/biomage/pipeline/local-runner/debug/dataIntegration.RData")
config
blah <- readRDS("~/Documents/Batcave/biomage/pipeline/local-runner/debug/dataIntegration.rds")
names(blah)
blah$config
setwd("~/Documents/Batcave/biomage/pipeline/local-runner")
list2env(readRDS('./debug/dataIntegration.rds'))
readRDS('./debug/dataIntegration.rds')
globalenv()
list2env(readRDS('./debug/dataIntegration.rds'), env = globalenv())
task_name <- 'dataIntegration'
message('DEBUG_STEP IS SET. ENTRYPOINT TO: ', task_name, 'IS SAVED.')
message('DEBUG_STEP IS SET. ENTRYPOINT TO: ', task_name, ' IS SAVED.')
message('DEBUG_STEP=', task_name)
message('DEBUG_STEP=', task_name, '. Saving arguments.')
message('DEBUG_STEP = ', task_name, '. Saving arguments.')
message("RUN list2env(readRDS('", fpath, "'), env=globalenv()) ", 'to restore environment.')
list2env(readRDS('/home/alex/Documents/Batcave/biomage/pipeline/local-runner/debug/dataIntegration_.rds'), env=globalenv())
list2env(readRDS('/home/alex/Documents/Batcave/biomage/pipeline/local-runner/debug/dataIntegration_.rds'), env=globalenv())
digest::digest(scdata)
print('DEBUG_STEP = ', task_name, '. Saving arguments.')
cat('DEBUG_STEP = ', task_name, '. Saving arguments.')
cat('DEBUG_STEP = ', task_name, '. Saving arguments.\n')
sprintf('DEBUG_STEP = ', task_name, '. Saving arguments.\n')
sprintf('DEBUG_STEP = %s', task_name, '. Saving arguments.\n')
sprintf('DEBUG_STEP = %s . Saving arguments.\n', task_name)
sprintf('DEBUG_STEP = %s. Saving arguments.\n', task_name)
sprintf('DEBUG_STEP = %s. Saving arguments.', task_name)
sprintf("RUN list2env(readRDS('%s'), env=globalenv()) to restore environment.")
sprintf("RUN list2env(readRDS('%s'), env=globalenv()) to restore environment.", fpath_host)
fpath_host <- 'blah'
sprintf("RUN list2env(readRDS('%s'), env=globalenv()) to restore environment.", fpath_host)
message(sprintf('DEBUG_STEP = %s. Saving arguments.', task_name))
dataIntegration <- readRDS("~/Documents/Batcave/biomage/pipeline/local-runner/debug/dataIntegration.rds")
install.packages('RestRserve')
